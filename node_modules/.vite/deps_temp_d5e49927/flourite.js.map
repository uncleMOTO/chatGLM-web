{
  "version": 3,
  "sources": ["../../flourite/dist/index.mjs"],
  "sourcesContent": ["const C = [\n    // Primitive variable declaration.\n    { pattern: /(char|long|int|float|double)\\s+\\w+\\s*=?/, type: \"constant.type\" },\n    // malloc function call\n    { pattern: /malloc\\(.+\\)/, type: \"keyword.function\" },\n    // #include <whatever.h>\n    { pattern: /#include (<|\")\\w+\\.h(>|\")/, type: \"meta.import\", nearTop: true },\n    // pointer\n    { pattern: /(\\w+)\\s*\\*\\s*\\w+/, type: \"keyword\" },\n    // Variable declaration and/or initialisation.\n    { pattern: /(\\w+)\\s+\\w+(;|\\s*=)/, type: \"macro\" },\n    // Array declaration.\n    { pattern: /(\\w+)\\s+\\w+\\[.+\\]/, type: \"keyword.other\" },\n    // #define macro\n    { pattern: /#define\\s+.+/, type: \"macro\" },\n    // NULL constant\n    { pattern: /NULL/, type: \"constant.null\" },\n    // void keyword\n    { pattern: /void/g, type: \"keyword.other\" },\n    // (else )if statement\n    // { pattern: /(else )?if\\s*\\(.+\\)\\s\\{/, points: 1 },\n    // while loop\n    // { pattern: /while\\s\\(.+\\)\\s\\{/, points: 1 },\n    // printf function\n    { pattern: /(printf|puts)\\s*\\(.+\\)/, type: \"keyword.print\" },\n    // new Keyword from C++\n    { pattern: /new \\w+/, type: \"not\" },\n    // new Keyword from Java\n    { pattern: /new [A-Z]\\w*\\s*\\(.+\\)/, type: \"not\" },\n    // Single quote multicharacter string\n    { pattern: /'.{2,}'/, type: \"not\" },\n    // JS variable declaration\n    { pattern: /var\\s+\\w+\\s*=?/, type: \"not\" },\n    // Avoiding Ruby confusion\n    { pattern: /def\\s+\\w+\\s*(\\(.+\\))?\\s*\\n/, type: \"not\" },\n    { pattern: /puts\\s+(\"|').+(\"|')/, type: \"not\" },\n    // Avoiding C# confusion\n    { pattern: /Console\\.(WriteLine|Write)(\\s*)?\\(/, type: \"not\" },\n    { pattern: /(using\\s)?System(\\..*)?(;)?/, type: \"not\" },\n    { pattern: /(public\\s)?((partial|static|delegate)\\s)?(class\\s)/, type: \"not\" },\n    { pattern: /(public|private|protected|internal)/, type: \"not\" },\n    {\n        pattern: /(new|this\\s)?(List|IEnumerable)<(sbyte|byte|short|ushort|int|uint|long|ulong|float|double|decimal|bool|char|string)>/,\n        type: \"not\"\n    },\n    // Avoiding Lua confusion\n    { pattern: /local\\s(function|\\w+)?/, type: \"not\" },\n    // Avoiding Dart confusion\n    { pattern: /^(void\\s)?main\\(\\)\\s(async\\s)?{/, type: \"not\" }\n];\n\nconst Clojure = [\n    { pattern: /^(\\s+)?\\(ns(\\s+)(.*)(\\))?$/, type: \"meta.module\" },\n    { pattern: /^(\\s+)?\\(print(ln)?(\\s+)(.*)(\\))$/, type: \"keyword.print\" },\n    { pattern: /^(\\s+)?\\((de)?fn(-)?(\\s+)(.*)(\\))?$/, type: \"keyword.function\" },\n    { pattern: /^(\\s+)?\\((let|def)(\\s+)(.*)(\\))?$/, type: \"keyword.variable\" },\n    // Collection & sequences\n    { pattern: /^(\\s+)?\\((class|coll\\?|seq\\?|range|cons|conj|concat|map|filter|reduce)(\\s+)(.*)(\\))?$/, type: \"keyword\" },\n    // Threading macro\n    { pattern: /^(\\s+)?\\((as)?->(>)?/, type: \"macro\" },\n    // Modules\n    { pattern: /^(\\s+)?\\((use|require|import|:import)(\\s+)(.*)(\\))?$/, type: \"meta.module\" },\n    // Control keywords\n    { pattern: /^(\\s+)?\\((do|if|loop|cond|when|or|and|condp|case)/, type: \"keyword.control\" }\n];\n\nconst CPP = [\n    // Primitive variable declaration.\n    { pattern: /(char|long|int|float|double)\\s+\\w+\\s*=?/, type: \"constant.type\" },\n    // #include <whatever.h>\n    { pattern: /#include\\s*(<|\")\\w+(\\.h)?(>|\")/, type: \"meta.import\" },\n    // using namespace something\n    { pattern: /using\\s+namespace\\s+.+\\s*;/, type: \"keyword\" },\n    // template declaration\n    { pattern: /template\\s*<.*>/, type: \"keyword\" },\n    // std\n    { pattern: /std::\\w+/g, type: \"keyword.other\" },\n    // cout/cin/endl\n    { pattern: /(cout|cin|endl)/g, type: \"keyword.print\" },\n    // Visibility specifiers\n    { pattern: /(public|protected|private):/, type: \"keyword.visibility\" },\n    // nullptr\n    { pattern: /nullptr/, type: \"keyword\" },\n    // new Keyword\n    { pattern: /new \\w+(\\(.*\\))?/, type: \"keyword\" },\n    // #define macro\n    { pattern: /#define\\s+.+/, type: \"macro\" },\n    // template usage\n    { pattern: /\\w+<\\w+>/, type: \"keyword.other\" },\n    // class keyword\n    { pattern: /class\\s+\\w+/, type: \"keyword\" },\n    // void keyword\n    { pattern: /void/g, type: \"keyword\" },\n    // (else )if statement\n    { pattern: /(else )?if\\s*\\(.+\\)/, type: \"keyword.control\" },\n    // while loop\n    { pattern: /while\\s+\\(.+\\)/, type: \"keyword.control\" },\n    // Scope operator\n    { pattern: /\\w*::\\w+/, type: \"macro\" },\n    // Single quote multicharacter string\n    { pattern: /'.{2,}'/, type: \"not\" },\n    // Java List/ArrayList\n    { pattern: /(List<\\w+>|ArrayList<\\w*>\\s*\\(.*\\))(\\s+[\\w]+|;)/, type: \"not\" },\n    // Avoiding Ruby confusion\n    { pattern: /def\\s+\\w+\\s*(\\(.+\\))?\\s*\\n/, type: \"not\" },\n    { pattern: /puts\\s+(\"|').+(\"|')/, type: \"not\" },\n    { pattern: /\\bmodule\\s\\S/, type: \"not\" },\n    // Avoiding C# confusion\n    { pattern: /Console\\.(WriteLine|Write)(\\s*)?\\(/, type: \"not\" },\n    { pattern: /(using\\s)?System(\\..*)?(;)?/, type: \"not\" },\n    { pattern: /static\\s+\\S+\\s+Main\\(.*\\)/, type: \"not\" },\n    { pattern: /(public|private|protected|internal)\\s/, type: \"not\" },\n    // Avoiding Kotlin confusion\n    { pattern: /fun main\\((.*)?\\) {/, type: \"not\" },\n    {\n        pattern: /(inline|private|public|protected|override|operator(\\s+))?fun(\\s+)([A-Za-z0-9_])(\\s+)?\\((.*)\\)(\\s+)({|=)/,\n        type: \"not\"\n    },\n    { pattern: /(const)?(\\s+)?val(\\s+)(.*)(:(\\s)(.*)(\\?)?)?(\\s+)=(\\s+)/, type: \"not\" },\n    // Avoiding Dart confusion\n    { pattern: /^(void\\s)?main\\(\\)\\s(async\\s)?{/, type: \"not\" }\n];\n\nconst CS = [\n    { pattern: /using\\sSystem(\\..*)?(;)?/, type: \"meta.import\" },\n    { pattern: /Console\\.(WriteLine|Write)(\\s*)?\\(/, type: \"keyword.print\" },\n    { pattern: /Console\\.ReadLine\\(\\)/, type: \"keyword.other\" },\n    { pattern: /(public\\s)?((partial|static|delegate)\\s)?class\\s/, type: \"keyword\" },\n    // Modifiers\n    { pattern: /(extern|override|sealed|readonly|virtual|volatile)/, type: \"keyword.other\" },\n    { pattern: /namespace\\s(.*)(\\.(.*))?(\\s{)?/, type: \"keyword\" },\n    // Regions\n    { pattern: /(#region(\\s.*)?|#endregion\\n)/, type: \"section.scope\" },\n    // Functions\n    { pattern: /(public|private|protected|internal)\\s/, type: \"keyword.visibility\" },\n    // class keyword\n    { pattern: /\\bclass\\s+\\w+/, type: \"keyword\" },\n    // (else )if statement\n    { pattern: /(else )?if\\s*\\(.+\\)/, type: \"keyword.control\" },\n    // while loop\n    { pattern: /\\bwhile\\s+\\(.+\\)/, type: \"keyword.control\" },\n    // Variable declaration\n    {\n        pattern: /(const\\s)?(sbyte|byte|short|ushort|int|uint|long|ulong|float|double|decimal|bool|char|string)(\\[\\])?\\s(.*)\\s=\\s(.*);/,\n        type: \"constant.type\"\n    },\n    // Lists\n    {\n        pattern: /(new|this\\s)?(List|IEnumerable)<(sbyte|byte|short|ushort|int|uint|long|ulong|float|double|decimal|bool|char|string)>/,\n        type: \"constant.dictionary\"\n    },\n    // Macro\n    { pattern: /#define\\s(.*)/, type: \"macro\" },\n    // Plus point if you're doing PascalCase\n    { pattern: /\\s([A-Z]([A-Z0-9]*[a-z][a-z0-9]*[A-Z]|[a-z0-9]*[A-Z][A-Z0-9]*[a-z])[A-Za-z0-9]*)\\s=/, type: \"macro\" },\n    // Avoiding Java confusion\n    { pattern: /(extends|throws|@Attribute)/, type: \"not\" },\n    { pattern: /System\\.(in|out)\\.\\w+/, type: \"not\" },\n    // Avoiding Ruby confusion\n    { pattern: /\\bmodule\\s\\S/, type: \"not\" },\n    // Avoiding Dart confusion\n    { pattern: /^\\s*import\\s(\"|')dart:\\w+(\"|')/, type: \"not\" }\n];\n\nconst CSS = [\n    // Properties\n    { pattern: /[a-z-]+:(?!:).+;/, type: \"keyword\" },\n    // <style> tag from HTML\n    { pattern: /<(\\/)?style>/, type: \"not\" }\n];\n\nconst Dart = [\n    // Variable declaration\n    {\n        pattern: /^\\s*(const|final|var|dynamic|late)?\\s*(int|double|String|bool|List<[A-Za-z [\\](),]+>|HashMap<[A-Za-z [\\](),]+>|Iterator<[A-Za-z [\\](),]+>|Set<[A-Za-z [\\](),]+>)?(\\?)?\\s\\w+(\\s=\\s.+)?(;|,)$/,\n        type: \"keyword.variable\"\n    },\n    { pattern: /\\bstdout.write\\(.+\\);/, type: \"keyword.print\" },\n    { pattern: /\\bprint\\(.+\\);/, type: \"keyword.print\" },\n    { pattern: /^\\s*import\\s(\"|')dart:\\w+(\"|')/, type: \"meta.import\", nearTop: true },\n    { pattern: /^\\s*import\\s(\"|')package:\\w+(\"|')/, type: \"meta.import\", nearTop: true },\n    { pattern: /^\\s*library\\s\\w+;/, type: \"meta.module\", nearTop: true },\n    { pattern: /^\\s*(void\\s)?main\\(\\)\\s(async\\s)?{/, type: \"keyword.function\" },\n    // function with type definition\n    {\n        pattern: /^\\s*(List<[A-Za-z [\\](),]+>|HashMap<[A-Za-z [\\](),]+>|int|double|String|bool|void|Iterator<[A-Za-z [\\](),]+>|Set<[A-Za-z [\\](),]+>)\\s\\w+\\(.+\\)\\s*\\{$/,\n        type: \"keyword.function\"\n    },\n    // arrow function\n    {\n        pattern: /^\\s*(int|double|String|bool|List<[A-Za-z [\\](),]+>|HashMap<[A-Za-z [\\](),]+>|Iterator<[A-Za-z [\\](),]+>|Set<[A-Za-z [\\](),]+>)\\s\\w+\\(.+\\)\\s=>/,\n        type: \"keyword.function\"\n    },\n    { pattern: /\\bnew\\s(List|Map|Iterator|HashMap|Set)<\\w+>\\(\\);$/, type: \"keyword.variable\" },\n    {\n        pattern: /^(abstract\\s)?class\\s\\w+\\s(extends\\s\\w+\\s)?(with\\s\\w+\\s)?(implements\\s\\w+\\s)?{(})?$/,\n        type: \"keyword.control\"\n    },\n    { pattern: /\\bget\\s\\w+=>\\w+/, type: \"keyword.control\" },\n    { pattern: /^\\s*@override$/, type: \"keyword.control\" },\n    { pattern: /\\bset\\s\\w+\\(.+\\)/, type: \"keyword.control\" },\n    { pattern: /^\\s*Future<w+>\\s\\w+\\(.+\\)\\sasync/, type: \"keyword.control\" },\n    { pattern: /^\\s*await\\sfor/, type: \"keyword.control\" },\n    { pattern: /^\\s*typedef\\s.+\\s=/, type: \"keyword.control\" },\n    // Avoiding confusion with C\n    { pattern: /\\blong\\s/, type: \"not\" },\n    { pattern: /\\s*function\\b/, type: \"not\" },\n    // Avoiding confusion with Java\n    { pattern: /\\bArrayList/, type: \"not\" }\n];\n\nconst KEYWORDS = [\n    \"ADD\",\n    \"ARG\",\n    \"AS\",\n    \"CMD\",\n    \"COPY\",\n    \"CROSS_BUILD\",\n    \"ENTRYPOINT\",\n    \"ENV\",\n    \"EXPOSE\",\n    \"FROM\",\n    \"HEALTHCHECK\",\n    \"LABEL\",\n    \"MAINTAINER\",\n    \"ONBUILD\",\n    \"RUN\",\n    \"SHELL\",\n    \"STOPSIGNAL\",\n    \"USER\",\n    \"VOLUME\",\n    \"WORKDIR\"\n];\nconst Dockerfile = [\n    // Keywords\n    // This should be enough to identify dockerfile since they always exist\n    { pattern: new RegExp(`^(${KEYWORDS.join(\"|\")})`), type: \"keyword\" }\n];\n\nconst Elixir = [\n    // Modules\n    { pattern: /^\\s*defmodule\\s+.+\\s+do$/, type: \"meta.module\" },\n    // Alias\n    { pattern: /\\s*alias\\s+.+as:.+/, type: \"keyword.other\" },\n    // IO.puts()\n    { pattern: /IO\\.puts.+/, type: \"keyword.print\" },\n    // Anonymous func\n    { pattern: /fn\\s+[A-Za-z0-9_:<>()]+\\s+->\\s+.+(end)?$/, type: \"keyword.function\" },\n    { pattern: /^\\s*(def|defp)\\s+.+\\s+do$/, type: \"keyword.function\" },\n    { pattern: /^\\s*(if|unless|cond|case|try|defimpl|defprotocol)\\s+.+\\s+do$/, type: \"keyword.control\" },\n    { pattern: /^\\s*defstruct\\s+/, type: \"keyword\" },\n    // Spec\n    { pattern: /^\\s*@spec\\s+.+::.+/, type: \"macro\" },\n    // Lists\n    { pattern: /\\{:.+,.+\\}/, type: \"constant.array\" },\n    // Maps\n    { pattern: /%\\{(.+(=>|:).+(,)?){1,}\\}/, type: \"constant.dictionary\" }\n];\n\nconst Go = [\n    // package something\n    { pattern: /package\\s+[a-z]+\\n/, type: \"meta.module\", nearTop: true },\n    // import\n    { pattern: /(import\\s*\\(\\s*\\n)|(import\\s+\"[a-z0-9/.]+\")/, type: \"meta.import\", nearTop: true },\n    // error check\n    { pattern: /if.+err\\s*!=\\s*nil.+{/, type: \"keyword.function\" },\n    // Go print\n    { pattern: /fmt\\.Print(f|ln)?\\(.*\\)/, type: \"keyword.print\" },\n    // function\n    { pattern: /func(\\s+\\w+\\s*)?\\(.*\\).*{/, type: \"keyword.function\" },\n    // variable initialisation\n    { pattern: /\\w+\\s*:=\\s*.+[^;\\n]/, type: \"keyword.variable\" },\n    // if/else if\n    { pattern: /(}\\s*else\\s*)?if[^()]+{/, type: \"keyword.control\" },\n    // var/const declaration\n    { pattern: /(var|const)\\s+\\w+\\s+[\\w*]+(\\n|\\s*=|$)/, type: \"keyword.variable\" },\n    // public access on package\n    { pattern: /[a-z]+\\.[A-Z]\\w*/, type: \"macro\" },\n    // nil keyword\n    { pattern: /nil/, type: \"keyword\" },\n    // Single quote multicharacter string\n    { pattern: /'.{2,}'/, type: \"not\" },\n    // Avoiding C# confusion\n    { pattern: /Console\\.(WriteLine|Write)(\\s*)?\\(/, type: \"not\" },\n    { pattern: /using\\sSystem(\\..*)?(;)?/, type: \"not\" },\n    { pattern: /(public|private|protected|internal)\\s/, type: \"not\" }\n];\n\nconst HTML = [\n    { pattern: /<!DOCTYPE (html|HTML PUBLIC .+)>/, type: \"meta.module\", nearTop: true },\n    // Tags\n    { pattern: /<[a-z0-9]+(\\s*[\\w]+=('|\").+('|\")\\s*)?>.*<\\/[a-z0-9]+>/g, type: \"keyword\" },\n    // Comments\n    { pattern: /<!--(.*)(-->)?/, type: \"comment.block\" },\n    // Properties\n    { pattern: /[a-z-]+=(\"|').+(\"|')/g, type: \"keyword.other\" },\n    // PHP tag\n    { pattern: /<\\?php/, type: \"not\" }\n];\n\nconst Java = [\n    // System.out.println() etc.\n    { pattern: /System\\.(in|out)\\.\\w+/, type: \"keyword.print\" },\n    // Class variable declarations\n    { pattern: /(private|protected|public)\\s*\\w+\\s*\\w+(\\s*=\\s*[\\w])?/, type: \"keyword\" },\n    // Method\n    { pattern: /(private|protected|public)\\s*\\w+\\s*[\\w]+\\(.+\\)/, type: \"keyword\" },\n    // String class\n    { pattern: /(^|\\s)(String)\\s+[\\w]+\\s*=?/, type: \"keyword.other\" },\n    // List/ArrayList\n    { pattern: /(List<\\w+>|ArrayList<\\w*>\\s*\\(.*\\))(\\s+[\\w]+|;)/, type: \"keyword.variable\" },\n    // class keyword\n    { pattern: /(public\\s*)?class\\b.*?\\{/, type: \"keyword\" },\n    // Array declaration.\n    { pattern: /(\\w+)(\\[\\s*\\])+\\s+\\w+/, type: \"constant.array\" },\n    // final keyword\n    { pattern: /final\\s*\\w+/, type: \"keyword.other\" },\n    // getter & setter\n    { pattern: /\\w+\\.(get|set)\\(.+\\)/, type: \"keyword.other\" },\n    // new Keyword (Java)\n    { pattern: /new [A-Z]\\w*\\s*\\(.+\\)/, type: \"keyword.other\" },\n    // C style variable declaration.\n    { pattern: /(^|\\s)(char|long|int|float|double)\\s+[\\w]+\\s*=?/, type: \"constant.type\" },\n    // extends/implements keywords\n    { pattern: /(extends|implements)/, type: \"meta.module\", nearTop: true },\n    // null keyword\n    { pattern: /null/g, type: \"keyword.other\" },\n    // (else )if statement\n    { pattern: /(else )?if\\s*\\(.+\\)/, type: \"keyword.control\" },\n    // while loop\n    { pattern: /while\\s+\\(.+\\)/, type: \"keyword.control\" },\n    // void keyword\n    { pattern: /void/, type: \"keyword.other\" },\n    // const\n    { pattern: /const\\s*\\w+/, type: \"not\" },\n    // pointer\n    { pattern: /(\\w+)\\s*\\*\\s*\\w+/, type: \"not\" },\n    // Single quote multicharacter string\n    { pattern: /'.{2,}'/, type: \"not\" },\n    // C style include\n    { pattern: /#include\\s*(<|\")\\w+(\\.h)?(>|\")/, type: \"not\", nearTop: true },\n    // Avoiding Ruby confusion\n    { pattern: /def\\s+\\w+\\s*(\\(.+\\))?\\s*\\n/, type: \"not\" },\n    // Avoiding C# confusion\n    { pattern: /\\bnamespace\\s.*(\\s{)?/, type: \"not\" },\n    { pattern: /\\[Attribute\\]/, type: \"not\" },\n    { pattern: /Console\\.(WriteLine|Write)(\\s*)?\\(/, type: \"not\" },\n    { pattern: /(#region(\\s.*)?|#endregion\\n)/, type: \"not\" },\n    { pattern: /using\\sSystem(\\..*)?(;)?/, type: \"not\" },\n    // Avoiding Kotlin confusion\n    { pattern: /fun main\\((.*)?\\) {/, type: \"not\" },\n    { pattern: /(inline(\\s+))?fun(\\s+)([A-Za-z0-9_])(\\s+)?\\((.*)\\)(\\s+)({|=)/, type: \"not\" },\n    { pattern: /(const)?(\\s+)?val(\\s+)(.*)(:(\\s)(.*)(\\?)?)?(\\s+)=(\\s+)/, type: \"not\" },\n    // Avoiding Dart confusion\n    { pattern: /^(void\\s)?main\\(\\)\\s{/, type: \"not\" }\n];\n\nconst Javascript = [\n    // undefined keyword\n    { pattern: /undefined/g, type: \"keyword\" },\n    // window keyword\n    { pattern: /window\\./g, type: \"keyword\" },\n    // console.log('ayy lmao')\n    { pattern: /console\\.log\\s*\\(/, type: \"keyword.print\" },\n    // Variable declaration\n    { pattern: /(var|const|let)\\s+\\w+\\s*=?/, type: \"keyword.variable\" },\n    // Array/Object declaration\n    { pattern: /(('|\").+('|\")\\s*|\\w+):\\s*[{[]/, type: \"constant.array\" },\n    // === operator\n    { pattern: /===/g, type: \"keyword.operator\" },\n    // !== operator\n    { pattern: /!==/g, type: \"keyword.operator\" },\n    // Function definition\n    { pattern: /function\\*?\\s*([A-Za-z$_][\\w$]*)?\\s*[(][^:;()]*[)]\\s*{/g, type: \"keyword.function\" },\n    // arrow function\n    { pattern: /\\(* => {/g, type: \"keyword.function\" },\n    // null keyword\n    { pattern: /null/g, type: \"constant.null\" },\n    // lambda expression\n    { pattern: /\\(.*\\)\\s*=>\\s*.+/, type: \"keyword.control\" },\n    // (else )if statement\n    { pattern: /(else )?if\\s+\\(.+\\)/, type: \"keyword.control\" },\n    // while loop\n    { pattern: /while\\s+\\(.+\\)/, type: \"keyword.control\" },\n    // C style variable declaration.\n    { pattern: /(^|\\s)(char|long|int|float|double)\\s+\\w+\\s*=?/, type: \"not\" },\n    // pointer\n    { pattern: /\\*\\w+/, type: \"not\" },\n    // HTML <script> tag\n    { pattern: /<(\\/)?script( type=('|\")text\\/javascript('|\"))?>/, type: \"not\" },\n    { pattern: /fn\\s[A-Za-z0-9<>,]+\\(.*\\)\\s->\\s\\w+(\\s\\{|)/, type: \"not\" },\n    // Avoiding C# confusion\n    { pattern: /Console\\.(WriteLine|Write)(\\s*)?\\(/, type: \"not\" },\n    { pattern: /(using\\s)?System(\\..*)?(;)?/, type: \"not\" },\n    { pattern: /(func|fn)\\s/, type: \"not\" },\n    { pattern: /(begin|end)\\n/, type: \"not\" },\n    // Avoiding Lua confusion\n    { pattern: /local\\s(function|(\\w+)\\s=)/, type: \"not\" },\n    // Avoiding Kotlin confusion\n    { pattern: /fun main\\((.*)?\\) {/, type: \"not\" },\n    { pattern: /(inline(\\s+))?fun(\\s+)([A-Za-z0-9_])(\\s+)?\\((.*)\\)(\\s+)({|=)/, type: \"not\" },\n    { pattern: /(const)?(\\s+)?val(\\s+)(.*)(:(\\s)(.*)(\\?)?)?(\\s+)=(\\s+)/, type: \"not\" },\n    // Avoiding Dart confusion\n    { pattern: /^(void\\s)?main()\\s{/, type: \"not\" }\n];\n\nconst Julia = [\n    // Module import\n    { pattern: /(using)\\s\\w+/, type: \"meta.import\" },\n    { pattern: /(bare\\s)?module/, type: \"meta.module\" },\n    // Avoiding Python's import\n    { pattern: /from\\s.+import\\s.+/, type: \"not\" },\n    // Stdout / print line\n    { pattern: /println\\(.*\\)/, type: \"keyword.print\" },\n    { pattern: /(.*)!\\(.*\\)/, type: \"macro\" },\n    // for x in / for x =\n    { pattern: /for\\s(\\w+)\\s(in|=)\\s/, type: \"keyword.control\" },\n    // It's not Julia if the function ends with {\n    { pattern: /function\\s\\w+\\(.*\\)\\s\\{/, type: \"not\" },\n    // It's not Julia either if the while loop has a brackets\n    { pattern: /while\\s+\\(.+\\)\\n/, type: \"not\" },\n    // The end keyword\n    { pattern: /end\\n?/, type: \"keyword\" },\n    // Struct with <: annotation\n    { pattern: /struct\\s(.*)\\s<:\\s/, type: \"keyword.other\" },\n    // Data types\n    { pattern: /(::)?(Int|Uint)(8|16|32|64|128)/, type: \"keyword.variable\" },\n    { pattern: /[0-9]+im/, type: \"keyword\" },\n    // Avoiding Rust confusion\n    { pattern: /\\{:\\?\\}/, type: \"not\" },\n    { pattern: /fn\\smain()/, type: \"not\" },\n    // Avoiding Ruby confusion\n    { pattern: /def\\s+\\w+\\s*(\\(.+\\))?\\s*\\n/, type: \"not\" },\n    { pattern: /puts\\s+(\"|').+(\"|')/, type: \"not\" },\n    { pattern: /class\\s/, type: \"not\" },\n    // Avoiding Lua confusion\n    { pattern: /local\\s(function|\\w+)/, type: \"not\" },\n    { pattern: /\\bmodule\\(.*\\)/, type: \"not\" },\n    // Avoiding Kotlin confusion\n    { pattern: /fun main\\((.*)?\\) {/, type: \"not\" },\n    { pattern: /fun(\\s+)([A-Za-z0-9_])(\\s+)?\\((.*)\\)(\\s+){/, type: \"not\" }\n];\n\nconst JSON = [\n    // object declaration on top\n    { pattern: /^\\{$/, type: \"meta.module\", nearTop: true },\n    // normal data type\n    { pattern: /^\\s*\".+\":\\s*(\".+\"|[0-9]+|null|true|false)(,)?$/, type: \"keyword\" },\n    // object and array\n    { pattern: /^\\s*\".+\":\\s*(\\{|\\[)$/, type: \"keyword\" },\n    // inline key/value pair in object\n    // e.g { \"id\": 1, \"body\": \"some comment\", \"postId\": 1 }\n    { pattern: /^\\s*\".+\":\\s*\\{(\\s*\".+\":\\s*(\".+\"|[0-9]+|null|true|false)(,)?\\s*){1,}\\}(,)?$/, type: \"keyword\" },\n    // inline value in array\n    // e.g \"middlewares\": [\"./fixtures/middlewares/en\", \"./fixtures/middlewares/jp\"]\n    { pattern: /\\s*\".+\"\\s*\\[\\s*((\".+\"|[0-9]+|null|true|false)(,)?\\s*){1,}\\](,)?$/, type: \"keyword\" }\n];\n\nconst Kotlin = [\n    { pattern: /fun main\\((.*)?\\) {/, type: \"keyword.function\" },\n    {\n        pattern: /(inline|private|public|protected|override|operator(\\s+))?fun(\\s+)([A-Za-z0-9_])(\\s+)?\\((.*)\\)(\\s+)({|=)/,\n        type: \"keyword.function\"\n    },\n    { pattern: /println\\((.*)\\)(\\n|;)/, type: \"keyword.print\" },\n    // (else )if statement\n    { pattern: /(else )?if\\s*\\(.+\\)/, type: \"keyword.control\" },\n    // while loop\n    { pattern: /while\\s+\\(.+\\)/, type: \"keyword.control\" },\n    // Variables\n    { pattern: /(const)?(\\s+)?val(\\s+)(.*)(:(\\s)(.*)(\\?)?)?(\\s+)=(\\s+)/, type: \"keyword.variable\" },\n    { pattern: /^(\\s+)?(inner|open|data)(\\s+)class/, type: \"keyword\" },\n    { pattern: /^import(\\s+)(.*)$/, type: \"meta.import\", nearTop: true },\n    { pattern: /typealias(\\s+)(.*)(\\s+)=/, type: \"keyword.control\" },\n    { pattern: /companion(\\s+)object/, type: \"keyword\" },\n    { pattern: /when(\\s+)(\\((.*)\\)\\s+)?{$/, type: \"keyword.control\" }\n];\n\nconst Lua = [\n    // multiline string\n    { pattern: /(\\[\\[.*\\]\\])/, type: \"constant.string\" },\n    // local definition\n    { pattern: /local\\s([a-zA-Z0-9_]+)(\\s*=)?/, type: \"keyword.variable\" },\n    // function definition\n    { pattern: /(local\\s)?function\\s*([a-zA-Z0-9_]*)?\\(\\)/, type: \"keyword.function\" },\n    // for loop\n    { pattern: /for\\s+([a-zA-Z]+)\\s*=\\s*([a-zA-Z0-9_]+),\\s*([a-zA-Z0-9_]+)\\s+do/, type: \"keyword.control\" },\n    // while loop\n    { pattern: /while\\s(.*)\\sdo/, type: \"keyword.control\" },\n    // keywords\n    {\n        pattern: /\\s+(and|break|do|else|elseif|end|false|function|if|in|not|or|local|repeat|return|then|true|until|pairs|ipairs|in|yield)/,\n        type: \"keyword.other\"\n    },\n    { pattern: /nil/, type: \"constant.null\" },\n    // length operator\n    { pattern: /#([a-zA-Z_{}]+)/, type: \"keyword.operator\" },\n    // metatables\n    { pattern: /((get|set)metatable|raw(get|set|equal))\\(.*\\)/, type: \"keyword.other\" },\n    // metamethods\n    { pattern: /__(index|newindex|call|sub|mul|div|mod|pow|unm|eq|le|lt)/, type: \"keyword.other\" },\n    // method invocation\n    { pattern: /(\\(.+\\)|([a-zA-Z_]+)):([a-zA-Z_])\\(.*\\)/, type: \"keyword.other\" },\n    // array-like table\n    { pattern: /{\\s*[^\\s;,]+([;,]\\s*[^\\s;,]+)*,?\\s*}/, type: \"constant.array\" },\n    // map-like table\n    {\n        pattern: /{\\s*([^\\s;,=]+\\s*=\\s*[^\\s;,=]+)(\\s*[;,=]\\s*[^\\s;,=]+\\s*=\\s*[^\\s;,=]+)*\\s*,?\\s*}/,\n        type: \"constant.dictionary\"\n    },\n    // builtin math methods\n    { pattern: /math\\.(.*)\\([0-9]*\\)/, type: \"macro\" },\n    // builtin table methods\n    { pattern: /table\\.(.*)\\(.*\\)/, type: \"macro\" },\n    // builtin io methods\n    { pattern: /io\\.(.*)\\(.*\\)/, type: \"macro\" },\n    // builtin functions\n    { pattern: /(require|dofile)\\((.*)\\)/, type: \"meta.import\" },\n    { pattern: /(pcall|xpcall|unpack|pack|coroutine)/, type: \"keyword.other\" },\n    // comments\n    { pattern: /--(\\[\\[)?.*/, type: \"comment.line\" },\n    // rest arguments\n    { pattern: /\\.\\.\\./, type: \"keyword.other\" },\n    // module usage\n    { pattern: /\\bmodule\\s*\\(.*\\)/, type: \"keyword.other\" },\n    // invalid comments\n    { pattern: /(\\/\\/|\\/\\*)/, type: \"not\" },\n    // avoid confusion with C\n    { pattern: /(#(include|define)|printf|\\s+int\\s+)/, type: \"not\" },\n    // avoid confusion with javascript\n    { pattern: /\\s+(let|const|var)\\s+/, type: \"not\" },\n    // avoid confusion with PHP & Python\n    { pattern: /\\s+(echo|die|\\$(.*))\\s+/, type: \"not\" },\n    // avoid confusion with Python\n    { pattern: /(def|len|from|import)/, type: \"not\" },\n    // avoid confusion with SQL\n    { pattern: /(SELECT|FROM|INSERT|ALTER)/, type: \"not\" },\n    // avoid confusion with Ruby\n    { pattern: /(puts)/, type: \"not\" },\n    { pattern: /\\bmodule\\s\\S/, type: \"not\" },\n    // avoid confusion Julia\n    { pattern: /(([a-zA-Z0-9]+)::([a-zA-Z0-9]+)|using|(.*)!\\(.*\\)|(\\|\\|))/, type: \"not\" }\n];\n\nconst Markdown = [\n    // headings\n    { pattern: /^(#){2,6}\\s.+/, type: \"keyword\" },\n    // headings alternate syntax\n    { pattern: /^(?!!)(?:=|-){2,}(?:>(?!$)|$)/, type: \"meta.module\" },\n    // images\n    { pattern: /(!)?\\[.+\\]\\(.+\\)/, type: \"keyword\" },\n    // links 2\n    { pattern: /\\[.+\\]\\[.+\\]/, type: \"keyword\" },\n    // links 3\n    { pattern: /^\\[.+\\]:\\s?(<)?(http)?/, type: \"keyword\" },\n    // blockquotes\n    { pattern: /^(> .*)+/, type: \"macro\" },\n    // code block\n    { pattern: /^```([A-Za-z0-9#_]+)?$/, type: \"keyword\" },\n    // frontmatter\n    { pattern: /^---$/, type: \"meta.module\", nearTop: true }\n];\n\nconst Pascal = [\n    { pattern: /^program (.*);$/, type: \"meta.module\", nearTop: true },\n    { pattern: /var$/i, type: \"constant.type\", nearTop: true },\n    { pattern: /const$/i, type: \"constant.type\", nearTop: true },\n    { pattern: /type$/i, type: \"constant.type\", nearTop: true },\n    { pattern: /(write|writeln)(\\s+)?(\\((.*)\\))?;/i, type: \"keyword.print\" },\n    { pattern: /^(\\s*)?(function|procedure)(\\s*)(.*)\\((.*)\\)(\\s)?:(\\s)?(.*);$/i, type: \"keyword.function\" },\n    { pattern: /end(\\.|;)/i, type: \"keyword.control\" },\n    { pattern: /:(\\s*)?(cardinal|shortint|smallint|word|extended|comp)(\\s*);$/i, type: \"constant.type\" },\n    { pattern: /if(\\s+)(.*)(\\s+)then/i, type: \"keyword.control\" },\n    { pattern: /for(\\s+)(.*):=(.*)(\\s+)(downto|to)(\\s+)(.*)(\\s+)do/i, type: \"keyword.control\" },\n    { pattern: /with(\\s+)(.*)(\\s+)do/i, type: \"keyword.control\" },\n    { pattern: /repeat$/, type: \"keyword\" },\n    { pattern: /begin$/, type: \"keyword\" },\n    { pattern: /until(\\s+)(.*);/i, type: \"keyword.control\" },\n    { pattern: /\\w+(\\s*)?:=(\\s*)?.+;$/i, type: \"keyword.variable\" }\n];\n\nconst PHP = [\n    // PHP tag\n    { pattern: /<\\?php/, type: \"meta.module\" },\n    // PHP style variables.\n    { pattern: /\\$\\w+/, type: \"keyword.variable\" },\n    // use Something\\Something;\n    { pattern: /use\\s+\\w+(\\\\\\w+)+\\s*;/, type: \"meta.import\", nearTop: true },\n    // arrow\n    { pattern: /\\$\\w+->\\w+/, type: \"keyword\" },\n    // require/include\n    { pattern: /(require|include)(_once)?\\s*\\(?\\s*('|\").+\\.php('|\")\\s*\\)?\\s*;/, type: \"meta.import\" },\n    // echo 'something';\n    { pattern: /echo\\s+('|\").+('|\")\\s*;/, type: \"keyword.print\" },\n    // NULL constant\n    { pattern: /NULL/, type: \"constant.null\" },\n    // new keyword\n    { pattern: /new\\s+((\\\\\\w+)+|\\w+)(\\(.*\\))?/, type: \"keyword\" },\n    // Function definition\n    { pattern: /function(\\s+[$\\w]+\\(.*\\)|\\s*\\(.*\\))/g, type: \"keyword.control\" },\n    // (else)if statement\n    { pattern: /(else)?if\\s+\\(.+\\)/, type: \"keyword.control\" },\n    // scope operator\n    { pattern: /\\w+::\\w+/, type: \"keyword\" },\n    // === operator\n    { pattern: /===/g, type: \"keyword.operator\" },\n    // !== operator\n    { pattern: /!==/g, type: \"keyword.operator\" },\n    // C/JS style variable declaration.\n    { pattern: /(^|\\s)(var|char|long|int|float|double)\\s+\\w+\\s*=?/, type: \"not\" },\n    // Javascript variable declaration\n    { pattern: /(var|const|let)\\s+\\w+\\s*=?/, type: \"not\" },\n    // Avoiding Lua confusion\n    { pattern: /local\\s(function|\\w+)/, type: \"not\" }\n];\n\nconst Python = [\n    // Function definition\n    { pattern: /def\\s+\\w+\\(.*\\)\\s*:/, type: \"keyword.function\" },\n    // while loop\n    { pattern: /while (.+):/, type: \"keyword.control\" },\n    // from library import something\n    { pattern: /from [\\w.]+ import (\\w+|\\*)/, type: \"meta.import\" },\n    // class keyword\n    { pattern: /class\\s*\\w+(\\(\\s*\\w+\\s*\\))?\\s*:/, type: \"keyword\" },\n    // if keyword\n    { pattern: /if\\s+(.+)\\s*:/, type: \"keyword.control\" },\n    // elif keyword\n    { pattern: /elif\\s+(.+)\\s*:/, type: \"keyword.control\" },\n    // else keyword\n    { pattern: /else:/, type: \"keyword.control\" },\n    // for loop\n    { pattern: /for (\\w+|\\(?\\w+,\\s*\\w+\\)?) in (.+):/, type: \"keyword.control\" },\n    // Python variable declaration.\n    { pattern: /\\w+\\s*=\\s*\\w+(?!;)(\\n|$)/, type: \"keyword\" },\n    // import something\n    { pattern: /import ([[^.]\\w])+/, type: \"meta.import\", nearTop: true },\n    // print statement/function\n    { pattern: /print((\\s*\\(.+\\))|\\s+.+)/, type: \"keyword.print\" },\n    // &&/|| operators\n    { pattern: /(&{2}|\\|{2})/, type: \"not\" },\n    // avoiding lua\n    { pattern: /elseif/, type: \"not\" },\n    { pattern: /local\\s(function|\\w+)?\\s=\\s/, type: \"not\" },\n    // Avoiding Kotlin confusion\n    { pattern: /fun main\\((.*)?\\) {/, type: \"not\" },\n    { pattern: /(inline(\\s+))?fun(\\s+)([A-Za-z0-9_])(\\s+)?\\((.*)\\)(\\s+)({|=)/, type: \"not\" },\n    { pattern: /(const)?(\\s+)?val(\\s+)(.*)(:(\\s)(.*)(\\?)?)?(\\s+)=(\\s+)/, type: \"not\" }\n];\n\nconst Ruby = [\n    // require/include\n    { pattern: /(require|include)\\s+'\\w+(\\.rb)?'/, type: \"meta.import\", nearTop: true },\n    // Function definition\n    { pattern: /def\\s+\\w+\\s*(\\(.+\\))?\\s*\\n/, type: \"keyword.function\" },\n    // Instance variables\n    { pattern: /@\\w+/, type: \"keyword.other\" },\n    // Boolean property\n    { pattern: /\\.\\w+\\?/, type: \"constant.boolean\" },\n    // puts (Ruby print)\n    { pattern: /puts\\s+(\"|').+(\"|')/, type: \"keyword.print\" },\n    // Inheriting class\n    { pattern: /class [A-Z]\\w*\\s*<\\s*([A-Z]\\w*(::)?)+/, type: \"keyword\" },\n    // attr_accessor\n    { pattern: /attr_accessor\\s+(:\\w+(,\\s*)?)+/, type: \"keyword.function\" },\n    // new\n    { pattern: /\\w+\\.new\\s+/, type: \"keyword\" },\n    // elsif keyword\n    { pattern: /elsif/, type: \"keyword.control\" },\n    // module\n    { pattern: /\\bmodule\\s\\S/, type: \"keyword.other\" },\n    // BEGIN and END\n    { pattern: /\\bBEGIN\\s\\{.*\\}/, type: \"keyword.other\" },\n    { pattern: /\\bEND\\s\\{.*\\}/, type: \"keyword.other\" },\n    // do\n    { pattern: /do\\s*[|]\\w+(,\\s*\\w+)*[|]/, type: \"keyword.control\" },\n    // for loop\n    { pattern: /for (\\w+|\\(?\\w+,\\s*\\w+\\)?) in (.+)/, type: \"keyword.control\" },\n    // nil keyword\n    { pattern: /nil/, type: \"constant.null\" },\n    // Scope operator\n    { pattern: /[A-Z]\\w*::[A-Z]\\w*/, type: \"macro\" }\n];\n\nconst Rust = [\n    { pattern: /fn\\smain()/, type: \"keyword.function\" },\n    { pattern: /(pub\\s)?fn\\s[A-Za-z0-9<>,]+\\(.*\\)\\s->\\s\\w+(\\s\\{|)/, type: \"keyword.visibility\" },\n    { pattern: /let\\smut\\s\\w+(\\s=|)/, type: \"keyword.variable\" },\n    { pattern: /(.*)!\\(.*\\)/, type: \"macro\" },\n    { pattern: /use\\s\\w+::.*/, type: \"meta.import\" },\n    { pattern: /\\{:\\?\\}/, type: \"keyword.other\" },\n    { pattern: /loop \\{/, type: \"keyword.control\" },\n    // Rust keywords\n    { pattern: /(impl|crate|extern|macro|box)/, type: \"keyword.other\" },\n    { pattern: /match\\s\\w+\\s\\{/, type: \"keyword.control\" },\n    { pattern: /\\w+\\.len\\(\\)/, type: \"keyword.other\" },\n    // Data types\n    { pattern: /(&str|(i|u)(8|16|32|64|128|size))/, type: \"constant.type\" },\n    // Vector\n    { pattern: /(Vec|Vec::new)|vec!/, type: \"constant.type\" },\n    // Traits\n    { pattern: /(Ok|Err|Box|ToOwned|Clone)/, type: \"keyword.other\" },\n    // Panic!!\n    { pattern: /panic!\\(.*\\)/, type: \"keyword.function\" },\n    // Avoiding clash with C#\n    { pattern: /using\\sSystem/, type: \"not\" },\n    { pattern: /Console\\.WriteLine\\s*\\(/, type: \"not\" },\n    { pattern: /(public\\s)?((partial|static)\\s)?class\\s/, type: \"not\" },\n    { pattern: /(function|func)\\s/, type: \"not\" }\n];\n\nconst SQL = [\n    { pattern: /CREATE (TABLE|DATABASE)/, type: \"keyword\", nearTop: true },\n    { pattern: /DROP (TABLE|DATABASE)/, type: \"keyword\", nearTop: true },\n    { pattern: /SHOW DATABASES/, type: \"keyword\", nearTop: true },\n    { pattern: /INSERT INTO/, type: \"keyword\" },\n    { pattern: /(SELECT|SELECT DISTINCT)\\s/, type: \"keyword\" },\n    { pattern: /INNER JOIN/, type: \"keyword\" },\n    { pattern: /(GROUP|ORDER) BY/, type: \"keyword\" },\n    { pattern: /(END;|COMMIT;)/, type: \"keyword\" },\n    { pattern: /UPDATE\\s+\\w+\\sSET/, type: \"keyword\" },\n    { pattern: /VALUES+(\\s+\\(\\w|\\(\\w)/, type: \"keyword\" },\n    // Comments\n    { pattern: /--\\s\\w/, type: \"comment.line\" },\n    // Data types\n    { pattern: /(VARCHAR|CHAR|BINARY|VARBINARY|BLOB|TEXT)\\([0-9]+\\)/, type: \"constant.type\" },\n    { pattern: /(BIT|TINYINT|SMALLINT|MEDIUMINT|INT|INTEGER|BIGINT|DOUBLE)\\([0-9]+\\)/, type: \"constant.type\" },\n    { pattern: /(TINYBLOB|TINYTEXT|MEDIUMTEXT|MEDIUMBLOB|LONGTEXT|LONGBLOB)/, type: \"constant.type\" },\n    { pattern: /(BOOLEAN|BOOL|DATE|YEAR)/, type: \"constant.type\" },\n    // Math\n    { pattern: /(EXP|SUM|SQRT|MIN|MAX)/, type: \"keyword.operator\" },\n    // Avoiding Lua\n    { pattern: /local\\s(function|\\w+)?\\s=\\s/, type: \"not\" },\n    { pattern: /(require|dofile)\\((.*)\\)/, type: \"not\" }\n];\n\nconst YAML = [\n    // Regular key: value\n    { pattern: /^( )*([A-Za-z0-9_. ]+):( )?(.*)?$/, type: \"keyword\" },\n    // Regular array - key: value\n    { pattern: /^( )*-( )([A-Za-z0-9_. ]+):( )?(.*)?$/, type: \"keyword\" },\n    // Regular array - value\n    { pattern: /^( )*-( )(.*)$/, type: \"keyword\" },\n    // Binary tag\n    { pattern: /^( )*([A-Za-z0-9_. ]+):( )!!binary( )?(|)?$/, type: \"constant.type\" },\n    // Literal multiline block\n    { pattern: /^( )*([A-Za-z0-9_. ]+):( )\\|$/, type: \"keyword\" },\n    // Folded multiline style\n    { pattern: /^( )*([A-Za-z0-9_. ]+):( )>$/, type: \"keyword\" },\n    // Set types\n    { pattern: /^( )*\\?( )(.*)$/, type: \"keyword\" },\n    // Complex key / multiline key\n    { pattern: /^( )*\\?( )\\|$/, type: \"constant.type\" },\n    // Merge key\n    { pattern: /^( )*<<:( )(\\*)(.*)?$/, type: \"constant.type\" },\n    // Avoiding confusion with CSS\n    { pattern: /^( )*([A-Za-z0-9_. ]+):(.*)?( )?{$/, type: \"not\" },\n    { pattern: /^( )*([A-Za-z0-9_. ]+):(.*)?( )?,$/, type: \"not\" }\n];\n\nfunction parsePoint(type) {\n    switch (type) {\n        case \"keyword.print\":\n        case \"meta.import\":\n        case \"meta.module\":\n            return 5;\n        case \"keyword.function\":\n        case \"constant.null\":\n            return 4;\n        case \"constant.type\":\n        case \"constant.string\":\n        case \"constant.numeric\":\n        case \"constant.boolean\":\n        case \"constant.dictionary\":\n        case \"constant.array\":\n        case \"keyword.variable\":\n            return 3;\n        case \"section.scope\":\n        case \"keyword.other\":\n        case \"keyword.operator\":\n        case \"keyword.control\":\n        case \"keyword.visibility\":\n        case \"keyword\":\n            return 2;\n        case \"comment.block\":\n        case \"comment.line\":\n        case \"comment.documentation\":\n        case \"macro\":\n            return 1;\n        case \"not\":\n        default:\n            return -20;\n    }\n}\n/**\n * Get points from a language using regular expressions.\n * @param {String} lineOfCode\n * @param {LanguagePattern[]} checkers\n * @returns {Number}\n */\nfunction getPoints(lineOfCode, checkers) {\n    const checker = checkers.map((o) => {\n        if (o.pattern.test(lineOfCode))\n            return parsePoint(o.type);\n        return 0;\n    });\n    const reduced = checker.reduce((memo, num) => memo + num, 0);\n    return reduced;\n}\n/**\n * Checks if a given string is near top of the code or not.\n * @param {Number} index\n * @param {String[]} linesOfCode\n * @returns {Boolean}\n */\nfunction nearTop(index, linesOfCode) {\n    if (linesOfCode.length <= 10) {\n        return true;\n    }\n    return index < linesOfCode.length / 10;\n}\n\n/**\n * Returns a language string that match with Shiki's language specification,\n * find it here: https://github.com/shikijs/shiki/blob/main/docs/languages.md\n * If the name is similar, we'll just convert it to lower case.\n * @param {String} language Language from the list\n * @returns {String} Shiki acceptable language\n */\nfunction convert(language) {\n    if (language === \"C++\")\n        return \"cpp\";\n    if (language === \"C#\")\n        return \"csharp\";\n    return language.toLowerCase();\n}\n\nconst shebangMap = {\n    node: \"Javascript\",\n    jsc: \"Javascript\",\n    rhino: \"Javascript\",\n    deno: \"Typescript\",\n    python3: \"Python\",\n    python2: \"Python\",\n    php: \"PHP\"\n};\n\nconst languages = {\n    C,\n    Clojure,\n    \"C++\": CPP,\n    \"C#\": CS,\n    CSS,\n    Dart,\n    Dockerfile,\n    Elixir,\n    Go,\n    HTML,\n    Java,\n    Javascript,\n    Julia,\n    JSON,\n    Kotlin,\n    Lua,\n    Markdown,\n    Pascal,\n    PHP,\n    Python,\n    Ruby,\n    Rust,\n    SQL,\n    YAML\n};\n/**\n * Detects a programming language from a given string.\n * @param {String} snippet The code we're guessing\n * @param {Options} options Options\n * @returns {DetectedLanguage} An object of DetectedLanguage\n * @example\n * ```js\n * import flourite from 'flourite';\n * const detect = flourite(code);\n * ```\n * @see Supported Languages - https://github.com/teknologi-umum/flourite#detectable-languages\n */\nfunction flourite(snippet, options = { heuristic: true, shiki: false, noUnknown: false }) {\n    let linesOfCode = snippet\n        .replace(/\\r\\n?/g, \"\\n\")\n        .replace(/\\n{2,}/g, \"\\n\")\n        .split(\"\\n\");\n    if (options.heuristic && linesOfCode.length > 500) {\n        linesOfCode = linesOfCode.filter((_, index) => {\n            if (nearTop(index, linesOfCode)) {\n                return true;\n            }\n            return index % Math.ceil(linesOfCode.length / 500) === 0;\n        });\n    }\n    // Shebang check\n    if (linesOfCode[0].startsWith(\"#!\")) {\n        if (linesOfCode[0].startsWith(\"#!/usr/bin/env\")) {\n            let language = linesOfCode[0].split(\" \").slice(1).join(\" \");\n            language = shebangMap[language] || language.charAt(0).toUpperCase() + language.slice(1);\n            return {\n                language: options.shiki ? convert(language) : language,\n                statistics: {},\n                linesOfCode: linesOfCode.length\n            };\n        }\n        if (linesOfCode[0].startsWith(\"#!/bin/bash\")) {\n            return {\n                language: options.shiki ? \"bash\" : \"Bash\",\n                statistics: {},\n                linesOfCode: linesOfCode.length\n            };\n        }\n    }\n    const pairs = Object.keys(languages).map((key) => ({ language: key, checkers: languages[key] }));\n    const results = [];\n    for (let i = 0; i < pairs.length; i++) {\n        const { language, checkers } = pairs[i];\n        let points = 0;\n        for (let j = 0; j < linesOfCode.length; j++) {\n            // fast return if the current line of code is empty or contains only spaces\n            if (/^\\s*$/.test(linesOfCode[j])) {\n                continue;\n            }\n            if (!nearTop(j, linesOfCode)) {\n                points += getPoints(linesOfCode[j], checkers.filter((checker) => !checker.nearTop));\n            }\n            else {\n                points += getPoints(linesOfCode[j], checkers);\n            }\n        }\n        results.push({ language, points });\n    }\n    if (!options.noUnknown) {\n        results.push({ language: \"Unknown\", points: 1 });\n    }\n    const bestResult = results.reduce((a, b) => a.points >= b.points ? a : b, { points: 0, language: \"\" });\n    const statistics = {};\n    for (let i = 0; i < results.length; i++) {\n        statistics[results[i].language] = results[i].points;\n    }\n    return {\n        language: options.shiki ? convert(bestResult.language) : bestResult.language,\n        statistics,\n        linesOfCode: linesOfCode.length\n    };\n}\n\nexport { flourite as default };\n"],
  "mappings": "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",
  "names": []
}
