'use strict';

const C = [
    // Primitive variable declaration.
    { pattern: /(char|long|int|float|double)\s+\w+\s*=?/, type: "constant.type" },
    // malloc function call
    { pattern: /malloc\(.+\)/, type: "keyword.function" },
    // #include <whatever.h>
    { pattern: /#include (<|")\w+\.h(>|")/, type: "meta.import", nearTop: true },
    // pointer
    { pattern: /(\w+)\s*\*\s*\w+/, type: "keyword" },
    // Variable declaration and/or initialisation.
    { pattern: /(\w+)\s+\w+(;|\s*=)/, type: "macro" },
    // Array declaration.
    { pattern: /(\w+)\s+\w+\[.+\]/, type: "keyword.other" },
    // #define macro
    { pattern: /#define\s+.+/, type: "macro" },
    // NULL constant
    { pattern: /NULL/, type: "constant.null" },
    // void keyword
    { pattern: /void/g, type: "keyword.other" },
    // (else )if statement
    // { pattern: /(else )?if\s*\(.+\)\s\{/, points: 1 },
    // while loop
    // { pattern: /while\s\(.+\)\s\{/, points: 1 },
    // printf function
    { pattern: /(printf|puts)\s*\(.+\)/, type: "keyword.print" },
    // new Keyword from C++
    { pattern: /new \w+/, type: "not" },
    // new Keyword from Java
    { pattern: /new [A-Z]\w*\s*\(.+\)/, type: "not" },
    // Single quote multicharacter string
    { pattern: /'.{2,}'/, type: "not" },
    // JS variable declaration
    { pattern: /var\s+\w+\s*=?/, type: "not" },
    // Avoiding Ruby confusion
    { pattern: /def\s+\w+\s*(\(.+\))?\s*\n/, type: "not" },
    { pattern: /puts\s+("|').+("|')/, type: "not" },
    // Avoiding C# confusion
    { pattern: /Console\.(WriteLine|Write)(\s*)?\(/, type: "not" },
    { pattern: /(using\s)?System(\..*)?(;)?/, type: "not" },
    { pattern: /(public\s)?((partial|static|delegate)\s)?(class\s)/, type: "not" },
    { pattern: /(public|private|protected|internal)/, type: "not" },
    {
        pattern: /(new|this\s)?(List|IEnumerable)<(sbyte|byte|short|ushort|int|uint|long|ulong|float|double|decimal|bool|char|string)>/,
        type: "not"
    },
    // Avoiding Lua confusion
    { pattern: /local\s(function|\w+)?/, type: "not" },
    // Avoiding Dart confusion
    { pattern: /^(void\s)?main\(\)\s(async\s)?{/, type: "not" }
];

const Clojure = [
    { pattern: /^(\s+)?\(ns(\s+)(.*)(\))?$/, type: "meta.module" },
    { pattern: /^(\s+)?\(print(ln)?(\s+)(.*)(\))$/, type: "keyword.print" },
    { pattern: /^(\s+)?\((de)?fn(-)?(\s+)(.*)(\))?$/, type: "keyword.function" },
    { pattern: /^(\s+)?\((let|def)(\s+)(.*)(\))?$/, type: "keyword.variable" },
    // Collection & sequences
    { pattern: /^(\s+)?\((class|coll\?|seq\?|range|cons|conj|concat|map|filter|reduce)(\s+)(.*)(\))?$/, type: "keyword" },
    // Threading macro
    { pattern: /^(\s+)?\((as)?->(>)?/, type: "macro" },
    // Modules
    { pattern: /^(\s+)?\((use|require|import|:import)(\s+)(.*)(\))?$/, type: "meta.module" },
    // Control keywords
    { pattern: /^(\s+)?\((do|if|loop|cond|when|or|and|condp|case)/, type: "keyword.control" }
];

const CPP = [
    // Primitive variable declaration.
    { pattern: /(char|long|int|float|double)\s+\w+\s*=?/, type: "constant.type" },
    // #include <whatever.h>
    { pattern: /#include\s*(<|")\w+(\.h)?(>|")/, type: "meta.import" },
    // using namespace something
    { pattern: /using\s+namespace\s+.+\s*;/, type: "keyword" },
    // template declaration
    { pattern: /template\s*<.*>/, type: "keyword" },
    // std
    { pattern: /std::\w+/g, type: "keyword.other" },
    // cout/cin/endl
    { pattern: /(cout|cin|endl)/g, type: "keyword.print" },
    // Visibility specifiers
    { pattern: /(public|protected|private):/, type: "keyword.visibility" },
    // nullptr
    { pattern: /nullptr/, type: "keyword" },
    // new Keyword
    { pattern: /new \w+(\(.*\))?/, type: "keyword" },
    // #define macro
    { pattern: /#define\s+.+/, type: "macro" },
    // template usage
    { pattern: /\w+<\w+>/, type: "keyword.other" },
    // class keyword
    { pattern: /class\s+\w+/, type: "keyword" },
    // void keyword
    { pattern: /void/g, type: "keyword" },
    // (else )if statement
    { pattern: /(else )?if\s*\(.+\)/, type: "keyword.control" },
    // while loop
    { pattern: /while\s+\(.+\)/, type: "keyword.control" },
    // Scope operator
    { pattern: /\w*::\w+/, type: "macro" },
    // Single quote multicharacter string
    { pattern: /'.{2,}'/, type: "not" },
    // Java List/ArrayList
    { pattern: /(List<\w+>|ArrayList<\w*>\s*\(.*\))(\s+[\w]+|;)/, type: "not" },
    // Avoiding Ruby confusion
    { pattern: /def\s+\w+\s*(\(.+\))?\s*\n/, type: "not" },
    { pattern: /puts\s+("|').+("|')/, type: "not" },
    { pattern: /\bmodule\s\S/, type: "not" },
    // Avoiding C# confusion
    { pattern: /Console\.(WriteLine|Write)(\s*)?\(/, type: "not" },
    { pattern: /(using\s)?System(\..*)?(;)?/, type: "not" },
    { pattern: /static\s+\S+\s+Main\(.*\)/, type: "not" },
    { pattern: /(public|private|protected|internal)\s/, type: "not" },
    // Avoiding Kotlin confusion
    { pattern: /fun main\((.*)?\) {/, type: "not" },
    {
        pattern: /(inline|private|public|protected|override|operator(\s+))?fun(\s+)([A-Za-z0-9_])(\s+)?\((.*)\)(\s+)({|=)/,
        type: "not"
    },
    { pattern: /(const)?(\s+)?val(\s+)(.*)(:(\s)(.*)(\?)?)?(\s+)=(\s+)/, type: "not" },
    // Avoiding Dart confusion
    { pattern: /^(void\s)?main\(\)\s(async\s)?{/, type: "not" }
];

const CS = [
    { pattern: /using\sSystem(\..*)?(;)?/, type: "meta.import" },
    { pattern: /Console\.(WriteLine|Write)(\s*)?\(/, type: "keyword.print" },
    { pattern: /Console\.ReadLine\(\)/, type: "keyword.other" },
    { pattern: /(public\s)?((partial|static|delegate)\s)?class\s/, type: "keyword" },
    // Modifiers
    { pattern: /(extern|override|sealed|readonly|virtual|volatile)/, type: "keyword.other" },
    { pattern: /namespace\s(.*)(\.(.*))?(\s{)?/, type: "keyword" },
    // Regions
    { pattern: /(#region(\s.*)?|#endregion\n)/, type: "section.scope" },
    // Functions
    { pattern: /(public|private|protected|internal)\s/, type: "keyword.visibility" },
    // class keyword
    { pattern: /\bclass\s+\w+/, type: "keyword" },
    // (else )if statement
    { pattern: /(else )?if\s*\(.+\)/, type: "keyword.control" },
    // while loop
    { pattern: /\bwhile\s+\(.+\)/, type: "keyword.control" },
    // Variable declaration
    {
        pattern: /(const\s)?(sbyte|byte|short|ushort|int|uint|long|ulong|float|double|decimal|bool|char|string)(\[\])?\s(.*)\s=\s(.*);/,
        type: "constant.type"
    },
    // Lists
    {
        pattern: /(new|this\s)?(List|IEnumerable)<(sbyte|byte|short|ushort|int|uint|long|ulong|float|double|decimal|bool|char|string)>/,
        type: "constant.dictionary"
    },
    // Macro
    { pattern: /#define\s(.*)/, type: "macro" },
    // Plus point if you're doing PascalCase
    { pattern: /\s([A-Z]([A-Z0-9]*[a-z][a-z0-9]*[A-Z]|[a-z0-9]*[A-Z][A-Z0-9]*[a-z])[A-Za-z0-9]*)\s=/, type: "macro" },
    // Avoiding Java confusion
    { pattern: /(extends|throws|@Attribute)/, type: "not" },
    { pattern: /System\.(in|out)\.\w+/, type: "not" },
    // Avoiding Ruby confusion
    { pattern: /\bmodule\s\S/, type: "not" },
    // Avoiding Dart confusion
    { pattern: /^\s*import\s("|')dart:\w+("|')/, type: "not" }
];

const CSS = [
    // Properties
    { pattern: /[a-z-]+:(?!:).+;/, type: "keyword" },
    // <style> tag from HTML
    { pattern: /<(\/)?style>/, type: "not" }
];

const Dart = [
    // Variable declaration
    {
        pattern: /^\s*(const|final|var|dynamic|late)?\s*(int|double|String|bool|List<[A-Za-z [\](),]+>|HashMap<[A-Za-z [\](),]+>|Iterator<[A-Za-z [\](),]+>|Set<[A-Za-z [\](),]+>)?(\?)?\s\w+(\s=\s.+)?(;|,)$/,
        type: "keyword.variable"
    },
    { pattern: /\bstdout.write\(.+\);/, type: "keyword.print" },
    { pattern: /\bprint\(.+\);/, type: "keyword.print" },
    { pattern: /^\s*import\s("|')dart:\w+("|')/, type: "meta.import", nearTop: true },
    { pattern: /^\s*import\s("|')package:\w+("|')/, type: "meta.import", nearTop: true },
    { pattern: /^\s*library\s\w+;/, type: "meta.module", nearTop: true },
    { pattern: /^\s*(void\s)?main\(\)\s(async\s)?{/, type: "keyword.function" },
    // function with type definition
    {
        pattern: /^\s*(List<[A-Za-z [\](),]+>|HashMap<[A-Za-z [\](),]+>|int|double|String|bool|void|Iterator<[A-Za-z [\](),]+>|Set<[A-Za-z [\](),]+>)\s\w+\(.+\)\s*\{$/,
        type: "keyword.function"
    },
    // arrow function
    {
        pattern: /^\s*(int|double|String|bool|List<[A-Za-z [\](),]+>|HashMap<[A-Za-z [\](),]+>|Iterator<[A-Za-z [\](),]+>|Set<[A-Za-z [\](),]+>)\s\w+\(.+\)\s=>/,
        type: "keyword.function"
    },
    { pattern: /\bnew\s(List|Map|Iterator|HashMap|Set)<\w+>\(\);$/, type: "keyword.variable" },
    {
        pattern: /^(abstract\s)?class\s\w+\s(extends\s\w+\s)?(with\s\w+\s)?(implements\s\w+\s)?{(})?$/,
        type: "keyword.control"
    },
    { pattern: /\bget\s\w+=>\w+/, type: "keyword.control" },
    { pattern: /^\s*@override$/, type: "keyword.control" },
    { pattern: /\bset\s\w+\(.+\)/, type: "keyword.control" },
    { pattern: /^\s*Future<w+>\s\w+\(.+\)\sasync/, type: "keyword.control" },
    { pattern: /^\s*await\sfor/, type: "keyword.control" },
    { pattern: /^\s*typedef\s.+\s=/, type: "keyword.control" },
    // Avoiding confusion with C
    { pattern: /\blong\s/, type: "not" },
    { pattern: /\s*function\b/, type: "not" },
    // Avoiding confusion with Java
    { pattern: /\bArrayList/, type: "not" }
];

const KEYWORDS = [
    "ADD",
    "ARG",
    "AS",
    "CMD",
    "COPY",
    "CROSS_BUILD",
    "ENTRYPOINT",
    "ENV",
    "EXPOSE",
    "FROM",
    "HEALTHCHECK",
    "LABEL",
    "MAINTAINER",
    "ONBUILD",
    "RUN",
    "SHELL",
    "STOPSIGNAL",
    "USER",
    "VOLUME",
    "WORKDIR"
];
const Dockerfile = [
    // Keywords
    // This should be enough to identify dockerfile since they always exist
    { pattern: new RegExp(`^(${KEYWORDS.join("|")})`), type: "keyword" }
];

const Elixir = [
    // Modules
    { pattern: /^\s*defmodule\s+.+\s+do$/, type: "meta.module" },
    // Alias
    { pattern: /\s*alias\s+.+as:.+/, type: "keyword.other" },
    // IO.puts()
    { pattern: /IO\.puts.+/, type: "keyword.print" },
    // Anonymous func
    { pattern: /fn\s+[A-Za-z0-9_:<>()]+\s+->\s+.+(end)?$/, type: "keyword.function" },
    { pattern: /^\s*(def|defp)\s+.+\s+do$/, type: "keyword.function" },
    { pattern: /^\s*(if|unless|cond|case|try|defimpl|defprotocol)\s+.+\s+do$/, type: "keyword.control" },
    { pattern: /^\s*defstruct\s+/, type: "keyword" },
    // Spec
    { pattern: /^\s*@spec\s+.+::.+/, type: "macro" },
    // Lists
    { pattern: /\{:.+,.+\}/, type: "constant.array" },
    // Maps
    { pattern: /%\{(.+(=>|:).+(,)?){1,}\}/, type: "constant.dictionary" }
];

const Go = [
    // package something
    { pattern: /package\s+[a-z]+\n/, type: "meta.module", nearTop: true },
    // import
    { pattern: /(import\s*\(\s*\n)|(import\s+"[a-z0-9/.]+")/, type: "meta.import", nearTop: true },
    // error check
    { pattern: /if.+err\s*!=\s*nil.+{/, type: "keyword.function" },
    // Go print
    { pattern: /fmt\.Print(f|ln)?\(.*\)/, type: "keyword.print" },
    // function
    { pattern: /func(\s+\w+\s*)?\(.*\).*{/, type: "keyword.function" },
    // variable initialisation
    { pattern: /\w+\s*:=\s*.+[^;\n]/, type: "keyword.variable" },
    // if/else if
    { pattern: /(}\s*else\s*)?if[^()]+{/, type: "keyword.control" },
    // var/const declaration
    { pattern: /(var|const)\s+\w+\s+[\w*]+(\n|\s*=|$)/, type: "keyword.variable" },
    // public access on package
    { pattern: /[a-z]+\.[A-Z]\w*/, type: "macro" },
    // nil keyword
    { pattern: /nil/, type: "keyword" },
    // Single quote multicharacter string
    { pattern: /'.{2,}'/, type: "not" },
    // Avoiding C# confusion
    { pattern: /Console\.(WriteLine|Write)(\s*)?\(/, type: "not" },
    { pattern: /using\sSystem(\..*)?(;)?/, type: "not" },
    { pattern: /(public|private|protected|internal)\s/, type: "not" }
];

const HTML = [
    { pattern: /<!DOCTYPE (html|HTML PUBLIC .+)>/, type: "meta.module", nearTop: true },
    // Tags
    { pattern: /<[a-z0-9]+(\s*[\w]+=('|").+('|")\s*)?>.*<\/[a-z0-9]+>/g, type: "keyword" },
    // Comments
    { pattern: /<!--(.*)(-->)?/, type: "comment.block" },
    // Properties
    { pattern: /[a-z-]+=("|').+("|')/g, type: "keyword.other" },
    // PHP tag
    { pattern: /<\?php/, type: "not" }
];

const Java = [
    // System.out.println() etc.
    { pattern: /System\.(in|out)\.\w+/, type: "keyword.print" },
    // Class variable declarations
    { pattern: /(private|protected|public)\s*\w+\s*\w+(\s*=\s*[\w])?/, type: "keyword" },
    // Method
    { pattern: /(private|protected|public)\s*\w+\s*[\w]+\(.+\)/, type: "keyword" },
    // String class
    { pattern: /(^|\s)(String)\s+[\w]+\s*=?/, type: "keyword.other" },
    // List/ArrayList
    { pattern: /(List<\w+>|ArrayList<\w*>\s*\(.*\))(\s+[\w]+|;)/, type: "keyword.variable" },
    // class keyword
    { pattern: /(public\s*)?class\b.*?\{/, type: "keyword" },
    // Array declaration.
    { pattern: /(\w+)(\[\s*\])+\s+\w+/, type: "constant.array" },
    // final keyword
    { pattern: /final\s*\w+/, type: "keyword.other" },
    // getter & setter
    { pattern: /\w+\.(get|set)\(.+\)/, type: "keyword.other" },
    // new Keyword (Java)
    { pattern: /new [A-Z]\w*\s*\(.+\)/, type: "keyword.other" },
    // C style variable declaration.
    { pattern: /(^|\s)(char|long|int|float|double)\s+[\w]+\s*=?/, type: "constant.type" },
    // extends/implements keywords
    { pattern: /(extends|implements)/, type: "meta.module", nearTop: true },
    // null keyword
    { pattern: /null/g, type: "keyword.other" },
    // (else )if statement
    { pattern: /(else )?if\s*\(.+\)/, type: "keyword.control" },
    // while loop
    { pattern: /while\s+\(.+\)/, type: "keyword.control" },
    // void keyword
    { pattern: /void/, type: "keyword.other" },
    // const
    { pattern: /const\s*\w+/, type: "not" },
    // pointer
    { pattern: /(\w+)\s*\*\s*\w+/, type: "not" },
    // Single quote multicharacter string
    { pattern: /'.{2,}'/, type: "not" },
    // C style include
    { pattern: /#include\s*(<|")\w+(\.h)?(>|")/, type: "not", nearTop: true },
    // Avoiding Ruby confusion
    { pattern: /def\s+\w+\s*(\(.+\))?\s*\n/, type: "not" },
    // Avoiding C# confusion
    { pattern: /\bnamespace\s.*(\s{)?/, type: "not" },
    { pattern: /\[Attribute\]/, type: "not" },
    { pattern: /Console\.(WriteLine|Write)(\s*)?\(/, type: "not" },
    { pattern: /(#region(\s.*)?|#endregion\n)/, type: "not" },
    { pattern: /using\sSystem(\..*)?(;)?/, type: "not" },
    // Avoiding Kotlin confusion
    { pattern: /fun main\((.*)?\) {/, type: "not" },
    { pattern: /(inline(\s+))?fun(\s+)([A-Za-z0-9_])(\s+)?\((.*)\)(\s+)({|=)/, type: "not" },
    { pattern: /(const)?(\s+)?val(\s+)(.*)(:(\s)(.*)(\?)?)?(\s+)=(\s+)/, type: "not" },
    // Avoiding Dart confusion
    { pattern: /^(void\s)?main\(\)\s{/, type: "not" }
];

const Javascript = [
    // undefined keyword
    { pattern: /undefined/g, type: "keyword" },
    // window keyword
    { pattern: /window\./g, type: "keyword" },
    // console.log('ayy lmao')
    { pattern: /console\.log\s*\(/, type: "keyword.print" },
    // Variable declaration
    { pattern: /(var|const|let)\s+\w+\s*=?/, type: "keyword.variable" },
    // Array/Object declaration
    { pattern: /(('|").+('|")\s*|\w+):\s*[{[]/, type: "constant.array" },
    // === operator
    { pattern: /===/g, type: "keyword.operator" },
    // !== operator
    { pattern: /!==/g, type: "keyword.operator" },
    // Function definition
    { pattern: /function\*?\s*([A-Za-z$_][\w$]*)?\s*[(][^:;()]*[)]\s*{/g, type: "keyword.function" },
    // arrow function
    { pattern: /\(* => {/g, type: "keyword.function" },
    // null keyword
    { pattern: /null/g, type: "constant.null" },
    // lambda expression
    { pattern: /\(.*\)\s*=>\s*.+/, type: "keyword.control" },
    // (else )if statement
    { pattern: /(else )?if\s+\(.+\)/, type: "keyword.control" },
    // while loop
    { pattern: /while\s+\(.+\)/, type: "keyword.control" },
    // C style variable declaration.
    { pattern: /(^|\s)(char|long|int|float|double)\s+\w+\s*=?/, type: "not" },
    // pointer
    { pattern: /\*\w+/, type: "not" },
    // HTML <script> tag
    { pattern: /<(\/)?script( type=('|")text\/javascript('|"))?>/, type: "not" },
    { pattern: /fn\s[A-Za-z0-9<>,]+\(.*\)\s->\s\w+(\s\{|)/, type: "not" },
    // Avoiding C# confusion
    { pattern: /Console\.(WriteLine|Write)(\s*)?\(/, type: "not" },
    { pattern: /(using\s)?System(\..*)?(;)?/, type: "not" },
    { pattern: /(func|fn)\s/, type: "not" },
    { pattern: /(begin|end)\n/, type: "not" },
    // Avoiding Lua confusion
    { pattern: /local\s(function|(\w+)\s=)/, type: "not" },
    // Avoiding Kotlin confusion
    { pattern: /fun main\((.*)?\) {/, type: "not" },
    { pattern: /(inline(\s+))?fun(\s+)([A-Za-z0-9_])(\s+)?\((.*)\)(\s+)({|=)/, type: "not" },
    { pattern: /(const)?(\s+)?val(\s+)(.*)(:(\s)(.*)(\?)?)?(\s+)=(\s+)/, type: "not" },
    // Avoiding Dart confusion
    { pattern: /^(void\s)?main()\s{/, type: "not" }
];

const Julia = [
    // Module import
    { pattern: /(using)\s\w+/, type: "meta.import" },
    { pattern: /(bare\s)?module/, type: "meta.module" },
    // Avoiding Python's import
    { pattern: /from\s.+import\s.+/, type: "not" },
    // Stdout / print line
    { pattern: /println\(.*\)/, type: "keyword.print" },
    { pattern: /(.*)!\(.*\)/, type: "macro" },
    // for x in / for x =
    { pattern: /for\s(\w+)\s(in|=)\s/, type: "keyword.control" },
    // It's not Julia if the function ends with {
    { pattern: /function\s\w+\(.*\)\s\{/, type: "not" },
    // It's not Julia either if the while loop has a brackets
    { pattern: /while\s+\(.+\)\n/, type: "not" },
    // The end keyword
    { pattern: /end\n?/, type: "keyword" },
    // Struct with <: annotation
    { pattern: /struct\s(.*)\s<:\s/, type: "keyword.other" },
    // Data types
    { pattern: /(::)?(Int|Uint)(8|16|32|64|128)/, type: "keyword.variable" },
    { pattern: /[0-9]+im/, type: "keyword" },
    // Avoiding Rust confusion
    { pattern: /\{:\?\}/, type: "not" },
    { pattern: /fn\smain()/, type: "not" },
    // Avoiding Ruby confusion
    { pattern: /def\s+\w+\s*(\(.+\))?\s*\n/, type: "not" },
    { pattern: /puts\s+("|').+("|')/, type: "not" },
    { pattern: /class\s/, type: "not" },
    // Avoiding Lua confusion
    { pattern: /local\s(function|\w+)/, type: "not" },
    { pattern: /\bmodule\(.*\)/, type: "not" },
    // Avoiding Kotlin confusion
    { pattern: /fun main\((.*)?\) {/, type: "not" },
    { pattern: /fun(\s+)([A-Za-z0-9_])(\s+)?\((.*)\)(\s+){/, type: "not" }
];

const JSON = [
    // object declaration on top
    { pattern: /^\{$/, type: "meta.module", nearTop: true },
    // normal data type
    { pattern: /^\s*".+":\s*(".+"|[0-9]+|null|true|false)(,)?$/, type: "keyword" },
    // object and array
    { pattern: /^\s*".+":\s*(\{|\[)$/, type: "keyword" },
    // inline key/value pair in object
    // e.g { "id": 1, "body": "some comment", "postId": 1 }
    { pattern: /^\s*".+":\s*\{(\s*".+":\s*(".+"|[0-9]+|null|true|false)(,)?\s*){1,}\}(,)?$/, type: "keyword" },
    // inline value in array
    // e.g "middlewares": ["./fixtures/middlewares/en", "./fixtures/middlewares/jp"]
    { pattern: /\s*".+"\s*\[\s*((".+"|[0-9]+|null|true|false)(,)?\s*){1,}\](,)?$/, type: "keyword" }
];

const Kotlin = [
    { pattern: /fun main\((.*)?\) {/, type: "keyword.function" },
    {
        pattern: /(inline|private|public|protected|override|operator(\s+))?fun(\s+)([A-Za-z0-9_])(\s+)?\((.*)\)(\s+)({|=)/,
        type: "keyword.function"
    },
    { pattern: /println\((.*)\)(\n|;)/, type: "keyword.print" },
    // (else )if statement
    { pattern: /(else )?if\s*\(.+\)/, type: "keyword.control" },
    // while loop
    { pattern: /while\s+\(.+\)/, type: "keyword.control" },
    // Variables
    { pattern: /(const)?(\s+)?val(\s+)(.*)(:(\s)(.*)(\?)?)?(\s+)=(\s+)/, type: "keyword.variable" },
    { pattern: /^(\s+)?(inner|open|data)(\s+)class/, type: "keyword" },
    { pattern: /^import(\s+)(.*)$/, type: "meta.import", nearTop: true },
    { pattern: /typealias(\s+)(.*)(\s+)=/, type: "keyword.control" },
    { pattern: /companion(\s+)object/, type: "keyword" },
    { pattern: /when(\s+)(\((.*)\)\s+)?{$/, type: "keyword.control" }
];

const Lua = [
    // multiline string
    { pattern: /(\[\[.*\]\])/, type: "constant.string" },
    // local definition
    { pattern: /local\s([a-zA-Z0-9_]+)(\s*=)?/, type: "keyword.variable" },
    // function definition
    { pattern: /(local\s)?function\s*([a-zA-Z0-9_]*)?\(\)/, type: "keyword.function" },
    // for loop
    { pattern: /for\s+([a-zA-Z]+)\s*=\s*([a-zA-Z0-9_]+),\s*([a-zA-Z0-9_]+)\s+do/, type: "keyword.control" },
    // while loop
    { pattern: /while\s(.*)\sdo/, type: "keyword.control" },
    // keywords
    {
        pattern: /\s+(and|break|do|else|elseif|end|false|function|if|in|not|or|local|repeat|return|then|true|until|pairs|ipairs|in|yield)/,
        type: "keyword.other"
    },
    { pattern: /nil/, type: "constant.null" },
    // length operator
    { pattern: /#([a-zA-Z_{}]+)/, type: "keyword.operator" },
    // metatables
    { pattern: /((get|set)metatable|raw(get|set|equal))\(.*\)/, type: "keyword.other" },
    // metamethods
    { pattern: /__(index|newindex|call|sub|mul|div|mod|pow|unm|eq|le|lt)/, type: "keyword.other" },
    // method invocation
    { pattern: /(\(.+\)|([a-zA-Z_]+)):([a-zA-Z_])\(.*\)/, type: "keyword.other" },
    // array-like table
    { pattern: /{\s*[^\s;,]+([;,]\s*[^\s;,]+)*,?\s*}/, type: "constant.array" },
    // map-like table
    {
        pattern: /{\s*([^\s;,=]+\s*=\s*[^\s;,=]+)(\s*[;,=]\s*[^\s;,=]+\s*=\s*[^\s;,=]+)*\s*,?\s*}/,
        type: "constant.dictionary"
    },
    // builtin math methods
    { pattern: /math\.(.*)\([0-9]*\)/, type: "macro" },
    // builtin table methods
    { pattern: /table\.(.*)\(.*\)/, type: "macro" },
    // builtin io methods
    { pattern: /io\.(.*)\(.*\)/, type: "macro" },
    // builtin functions
    { pattern: /(require|dofile)\((.*)\)/, type: "meta.import" },
    { pattern: /(pcall|xpcall|unpack|pack|coroutine)/, type: "keyword.other" },
    // comments
    { pattern: /--(\[\[)?.*/, type: "comment.line" },
    // rest arguments
    { pattern: /\.\.\./, type: "keyword.other" },
    // module usage
    { pattern: /\bmodule\s*\(.*\)/, type: "keyword.other" },
    // invalid comments
    { pattern: /(\/\/|\/\*)/, type: "not" },
    // avoid confusion with C
    { pattern: /(#(include|define)|printf|\s+int\s+)/, type: "not" },
    // avoid confusion with javascript
    { pattern: /\s+(let|const|var)\s+/, type: "not" },
    // avoid confusion with PHP & Python
    { pattern: /\s+(echo|die|\$(.*))\s+/, type: "not" },
    // avoid confusion with Python
    { pattern: /(def|len|from|import)/, type: "not" },
    // avoid confusion with SQL
    { pattern: /(SELECT|FROM|INSERT|ALTER)/, type: "not" },
    // avoid confusion with Ruby
    { pattern: /(puts)/, type: "not" },
    { pattern: /\bmodule\s\S/, type: "not" },
    // avoid confusion Julia
    { pattern: /(([a-zA-Z0-9]+)::([a-zA-Z0-9]+)|using|(.*)!\(.*\)|(\|\|))/, type: "not" }
];

const Markdown = [
    // headings
    { pattern: /^(#){2,6}\s.+/, type: "keyword" },
    // headings alternate syntax
    { pattern: /^(?!!)(?:=|-){2,}(?:>(?!$)|$)/, type: "meta.module" },
    // images
    { pattern: /(!)?\[.+\]\(.+\)/, type: "keyword" },
    // links 2
    { pattern: /\[.+\]\[.+\]/, type: "keyword" },
    // links 3
    { pattern: /^\[.+\]:\s?(<)?(http)?/, type: "keyword" },
    // blockquotes
    { pattern: /^(> .*)+/, type: "macro" },
    // code block
    { pattern: /^```([A-Za-z0-9#_]+)?$/, type: "keyword" },
    // frontmatter
    { pattern: /^---$/, type: "meta.module", nearTop: true }
];

const Pascal = [
    { pattern: /^program (.*);$/, type: "meta.module", nearTop: true },
    { pattern: /var$/i, type: "constant.type", nearTop: true },
    { pattern: /const$/i, type: "constant.type", nearTop: true },
    { pattern: /type$/i, type: "constant.type", nearTop: true },
    { pattern: /(write|writeln)(\s+)?(\((.*)\))?;/i, type: "keyword.print" },
    { pattern: /^(\s*)?(function|procedure)(\s*)(.*)\((.*)\)(\s)?:(\s)?(.*);$/i, type: "keyword.function" },
    { pattern: /end(\.|;)/i, type: "keyword.control" },
    { pattern: /:(\s*)?(cardinal|shortint|smallint|word|extended|comp)(\s*);$/i, type: "constant.type" },
    { pattern: /if(\s+)(.*)(\s+)then/i, type: "keyword.control" },
    { pattern: /for(\s+)(.*):=(.*)(\s+)(downto|to)(\s+)(.*)(\s+)do/i, type: "keyword.control" },
    { pattern: /with(\s+)(.*)(\s+)do/i, type: "keyword.control" },
    { pattern: /repeat$/, type: "keyword" },
    { pattern: /begin$/, type: "keyword" },
    { pattern: /until(\s+)(.*);/i, type: "keyword.control" },
    { pattern: /\w+(\s*)?:=(\s*)?.+;$/i, type: "keyword.variable" }
];

const PHP = [
    // PHP tag
    { pattern: /<\?php/, type: "meta.module" },
    // PHP style variables.
    { pattern: /\$\w+/, type: "keyword.variable" },
    // use Something\Something;
    { pattern: /use\s+\w+(\\\w+)+\s*;/, type: "meta.import", nearTop: true },
    // arrow
    { pattern: /\$\w+->\w+/, type: "keyword" },
    // require/include
    { pattern: /(require|include)(_once)?\s*\(?\s*('|").+\.php('|")\s*\)?\s*;/, type: "meta.import" },
    // echo 'something';
    { pattern: /echo\s+('|").+('|")\s*;/, type: "keyword.print" },
    // NULL constant
    { pattern: /NULL/, type: "constant.null" },
    // new keyword
    { pattern: /new\s+((\\\w+)+|\w+)(\(.*\))?/, type: "keyword" },
    // Function definition
    { pattern: /function(\s+[$\w]+\(.*\)|\s*\(.*\))/g, type: "keyword.control" },
    // (else)if statement
    { pattern: /(else)?if\s+\(.+\)/, type: "keyword.control" },
    // scope operator
    { pattern: /\w+::\w+/, type: "keyword" },
    // === operator
    { pattern: /===/g, type: "keyword.operator" },
    // !== operator
    { pattern: /!==/g, type: "keyword.operator" },
    // C/JS style variable declaration.
    { pattern: /(^|\s)(var|char|long|int|float|double)\s+\w+\s*=?/, type: "not" },
    // Javascript variable declaration
    { pattern: /(var|const|let)\s+\w+\s*=?/, type: "not" },
    // Avoiding Lua confusion
    { pattern: /local\s(function|\w+)/, type: "not" }
];

const Python = [
    // Function definition
    { pattern: /def\s+\w+\(.*\)\s*:/, type: "keyword.function" },
    // while loop
    { pattern: /while (.+):/, type: "keyword.control" },
    // from library import something
    { pattern: /from [\w.]+ import (\w+|\*)/, type: "meta.import" },
    // class keyword
    { pattern: /class\s*\w+(\(\s*\w+\s*\))?\s*:/, type: "keyword" },
    // if keyword
    { pattern: /if\s+(.+)\s*:/, type: "keyword.control" },
    // elif keyword
    { pattern: /elif\s+(.+)\s*:/, type: "keyword.control" },
    // else keyword
    { pattern: /else:/, type: "keyword.control" },
    // for loop
    { pattern: /for (\w+|\(?\w+,\s*\w+\)?) in (.+):/, type: "keyword.control" },
    // Python variable declaration.
    { pattern: /\w+\s*=\s*\w+(?!;)(\n|$)/, type: "keyword" },
    // import something
    { pattern: /import ([[^.]\w])+/, type: "meta.import", nearTop: true },
    // print statement/function
    { pattern: /print((\s*\(.+\))|\s+.+)/, type: "keyword.print" },
    // &&/|| operators
    { pattern: /(&{2}|\|{2})/, type: "not" },
    // avoiding lua
    { pattern: /elseif/, type: "not" },
    { pattern: /local\s(function|\w+)?\s=\s/, type: "not" },
    // Avoiding Kotlin confusion
    { pattern: /fun main\((.*)?\) {/, type: "not" },
    { pattern: /(inline(\s+))?fun(\s+)([A-Za-z0-9_])(\s+)?\((.*)\)(\s+)({|=)/, type: "not" },
    { pattern: /(const)?(\s+)?val(\s+)(.*)(:(\s)(.*)(\?)?)?(\s+)=(\s+)/, type: "not" }
];

const Ruby = [
    // require/include
    { pattern: /(require|include)\s+'\w+(\.rb)?'/, type: "meta.import", nearTop: true },
    // Function definition
    { pattern: /def\s+\w+\s*(\(.+\))?\s*\n/, type: "keyword.function" },
    // Instance variables
    { pattern: /@\w+/, type: "keyword.other" },
    // Boolean property
    { pattern: /\.\w+\?/, type: "constant.boolean" },
    // puts (Ruby print)
    { pattern: /puts\s+("|').+("|')/, type: "keyword.print" },
    // Inheriting class
    { pattern: /class [A-Z]\w*\s*<\s*([A-Z]\w*(::)?)+/, type: "keyword" },
    // attr_accessor
    { pattern: /attr_accessor\s+(:\w+(,\s*)?)+/, type: "keyword.function" },
    // new
    { pattern: /\w+\.new\s+/, type: "keyword" },
    // elsif keyword
    { pattern: /elsif/, type: "keyword.control" },
    // module
    { pattern: /\bmodule\s\S/, type: "keyword.other" },
    // BEGIN and END
    { pattern: /\bBEGIN\s\{.*\}/, type: "keyword.other" },
    { pattern: /\bEND\s\{.*\}/, type: "keyword.other" },
    // do
    { pattern: /do\s*[|]\w+(,\s*\w+)*[|]/, type: "keyword.control" },
    // for loop
    { pattern: /for (\w+|\(?\w+,\s*\w+\)?) in (.+)/, type: "keyword.control" },
    // nil keyword
    { pattern: /nil/, type: "constant.null" },
    // Scope operator
    { pattern: /[A-Z]\w*::[A-Z]\w*/, type: "macro" }
];

const Rust = [
    { pattern: /fn\smain()/, type: "keyword.function" },
    { pattern: /(pub\s)?fn\s[A-Za-z0-9<>,]+\(.*\)\s->\s\w+(\s\{|)/, type: "keyword.visibility" },
    { pattern: /let\smut\s\w+(\s=|)/, type: "keyword.variable" },
    { pattern: /(.*)!\(.*\)/, type: "macro" },
    { pattern: /use\s\w+::.*/, type: "meta.import" },
    { pattern: /\{:\?\}/, type: "keyword.other" },
    { pattern: /loop \{/, type: "keyword.control" },
    // Rust keywords
    { pattern: /(impl|crate|extern|macro|box)/, type: "keyword.other" },
    { pattern: /match\s\w+\s\{/, type: "keyword.control" },
    { pattern: /\w+\.len\(\)/, type: "keyword.other" },
    // Data types
    { pattern: /(&str|(i|u)(8|16|32|64|128|size))/, type: "constant.type" },
    // Vector
    { pattern: /(Vec|Vec::new)|vec!/, type: "constant.type" },
    // Traits
    { pattern: /(Ok|Err|Box|ToOwned|Clone)/, type: "keyword.other" },
    // Panic!!
    { pattern: /panic!\(.*\)/, type: "keyword.function" },
    // Avoiding clash with C#
    { pattern: /using\sSystem/, type: "not" },
    { pattern: /Console\.WriteLine\s*\(/, type: "not" },
    { pattern: /(public\s)?((partial|static)\s)?class\s/, type: "not" },
    { pattern: /(function|func)\s/, type: "not" }
];

const SQL = [
    { pattern: /CREATE (TABLE|DATABASE)/, type: "keyword", nearTop: true },
    { pattern: /DROP (TABLE|DATABASE)/, type: "keyword", nearTop: true },
    { pattern: /SHOW DATABASES/, type: "keyword", nearTop: true },
    { pattern: /INSERT INTO/, type: "keyword" },
    { pattern: /(SELECT|SELECT DISTINCT)\s/, type: "keyword" },
    { pattern: /INNER JOIN/, type: "keyword" },
    { pattern: /(GROUP|ORDER) BY/, type: "keyword" },
    { pattern: /(END;|COMMIT;)/, type: "keyword" },
    { pattern: /UPDATE\s+\w+\sSET/, type: "keyword" },
    { pattern: /VALUES+(\s+\(\w|\(\w)/, type: "keyword" },
    // Comments
    { pattern: /--\s\w/, type: "comment.line" },
    // Data types
    { pattern: /(VARCHAR|CHAR|BINARY|VARBINARY|BLOB|TEXT)\([0-9]+\)/, type: "constant.type" },
    { pattern: /(BIT|TINYINT|SMALLINT|MEDIUMINT|INT|INTEGER|BIGINT|DOUBLE)\([0-9]+\)/, type: "constant.type" },
    { pattern: /(TINYBLOB|TINYTEXT|MEDIUMTEXT|MEDIUMBLOB|LONGTEXT|LONGBLOB)/, type: "constant.type" },
    { pattern: /(BOOLEAN|BOOL|DATE|YEAR)/, type: "constant.type" },
    // Math
    { pattern: /(EXP|SUM|SQRT|MIN|MAX)/, type: "keyword.operator" },
    // Avoiding Lua
    { pattern: /local\s(function|\w+)?\s=\s/, type: "not" },
    { pattern: /(require|dofile)\((.*)\)/, type: "not" }
];

const YAML = [
    // Regular key: value
    { pattern: /^( )*([A-Za-z0-9_. ]+):( )?(.*)?$/, type: "keyword" },
    // Regular array - key: value
    { pattern: /^( )*-( )([A-Za-z0-9_. ]+):( )?(.*)?$/, type: "keyword" },
    // Regular array - value
    { pattern: /^( )*-( )(.*)$/, type: "keyword" },
    // Binary tag
    { pattern: /^( )*([A-Za-z0-9_. ]+):( )!!binary( )?(|)?$/, type: "constant.type" },
    // Literal multiline block
    { pattern: /^( )*([A-Za-z0-9_. ]+):( )\|$/, type: "keyword" },
    // Folded multiline style
    { pattern: /^( )*([A-Za-z0-9_. ]+):( )>$/, type: "keyword" },
    // Set types
    { pattern: /^( )*\?( )(.*)$/, type: "keyword" },
    // Complex key / multiline key
    { pattern: /^( )*\?( )\|$/, type: "constant.type" },
    // Merge key
    { pattern: /^( )*<<:( )(\*)(.*)?$/, type: "constant.type" },
    // Avoiding confusion with CSS
    { pattern: /^( )*([A-Za-z0-9_. ]+):(.*)?( )?{$/, type: "not" },
    { pattern: /^( )*([A-Za-z0-9_. ]+):(.*)?( )?,$/, type: "not" }
];

function parsePoint(type) {
    switch (type) {
        case "keyword.print":
        case "meta.import":
        case "meta.module":
            return 5;
        case "keyword.function":
        case "constant.null":
            return 4;
        case "constant.type":
        case "constant.string":
        case "constant.numeric":
        case "constant.boolean":
        case "constant.dictionary":
        case "constant.array":
        case "keyword.variable":
            return 3;
        case "section.scope":
        case "keyword.other":
        case "keyword.operator":
        case "keyword.control":
        case "keyword.visibility":
        case "keyword":
            return 2;
        case "comment.block":
        case "comment.line":
        case "comment.documentation":
        case "macro":
            return 1;
        case "not":
        default:
            return -20;
    }
}
/**
 * Get points from a language using regular expressions.
 * @param {String} lineOfCode
 * @param {LanguagePattern[]} checkers
 * @returns {Number}
 */
function getPoints(lineOfCode, checkers) {
    const checker = checkers.map((o) => {
        if (o.pattern.test(lineOfCode))
            return parsePoint(o.type);
        return 0;
    });
    const reduced = checker.reduce((memo, num) => memo + num, 0);
    return reduced;
}
/**
 * Checks if a given string is near top of the code or not.
 * @param {Number} index
 * @param {String[]} linesOfCode
 * @returns {Boolean}
 */
function nearTop(index, linesOfCode) {
    if (linesOfCode.length <= 10) {
        return true;
    }
    return index < linesOfCode.length / 10;
}

/**
 * Returns a language string that match with Shiki's language specification,
 * find it here: https://github.com/shikijs/shiki/blob/main/docs/languages.md
 * If the name is similar, we'll just convert it to lower case.
 * @param {String} language Language from the list
 * @returns {String} Shiki acceptable language
 */
function convert(language) {
    if (language === "C++")
        return "cpp";
    if (language === "C#")
        return "csharp";
    return language.toLowerCase();
}

const shebangMap = {
    node: "Javascript",
    jsc: "Javascript",
    rhino: "Javascript",
    deno: "Typescript",
    python3: "Python",
    python2: "Python",
    php: "PHP"
};

const languages = {
    C,
    Clojure,
    "C++": CPP,
    "C#": CS,
    CSS,
    Dart,
    Dockerfile,
    Elixir,
    Go,
    HTML,
    Java,
    Javascript,
    Julia,
    JSON,
    Kotlin,
    Lua,
    Markdown,
    Pascal,
    PHP,
    Python,
    Ruby,
    Rust,
    SQL,
    YAML
};
/**
 * Detects a programming language from a given string.
 * @param {String} snippet The code we're guessing
 * @param {Options} options Options
 * @returns {DetectedLanguage} An object of DetectedLanguage
 * @example
 * ```js
 * import flourite from 'flourite';
 * const detect = flourite(code);
 * ```
 * @see Supported Languages - https://github.com/teknologi-umum/flourite#detectable-languages
 */
function flourite(snippet, options = { heuristic: true, shiki: false, noUnknown: false }) {
    let linesOfCode = snippet
        .replace(/\r\n?/g, "\n")
        .replace(/\n{2,}/g, "\n")
        .split("\n");
    if (options.heuristic && linesOfCode.length > 500) {
        linesOfCode = linesOfCode.filter((_, index) => {
            if (nearTop(index, linesOfCode)) {
                return true;
            }
            return index % Math.ceil(linesOfCode.length / 500) === 0;
        });
    }
    // Shebang check
    if (linesOfCode[0].startsWith("#!")) {
        if (linesOfCode[0].startsWith("#!/usr/bin/env")) {
            let language = linesOfCode[0].split(" ").slice(1).join(" ");
            language = shebangMap[language] || language.charAt(0).toUpperCase() + language.slice(1);
            return {
                language: options.shiki ? convert(language) : language,
                statistics: {},
                linesOfCode: linesOfCode.length
            };
        }
        if (linesOfCode[0].startsWith("#!/bin/bash")) {
            return {
                language: options.shiki ? "bash" : "Bash",
                statistics: {},
                linesOfCode: linesOfCode.length
            };
        }
    }
    const pairs = Object.keys(languages).map((key) => ({ language: key, checkers: languages[key] }));
    const results = [];
    for (let i = 0; i < pairs.length; i++) {
        const { language, checkers } = pairs[i];
        let points = 0;
        for (let j = 0; j < linesOfCode.length; j++) {
            // fast return if the current line of code is empty or contains only spaces
            if (/^\s*$/.test(linesOfCode[j])) {
                continue;
            }
            if (!nearTop(j, linesOfCode)) {
                points += getPoints(linesOfCode[j], checkers.filter((checker) => !checker.nearTop));
            }
            else {
                points += getPoints(linesOfCode[j], checkers);
            }
        }
        results.push({ language, points });
    }
    if (!options.noUnknown) {
        results.push({ language: "Unknown", points: 1 });
    }
    const bestResult = results.reduce((a, b) => a.points >= b.points ? a : b, { points: 0, language: "" });
    const statistics = {};
    for (let i = 0; i < results.length; i++) {
        statistics[results[i].language] = results[i].points;
    }
    return {
        language: options.shiki ? convert(bestResult.language) : bestResult.language,
        statistics,
        linesOfCode: linesOfCode.length
    };
}

module.exports = flourite;
